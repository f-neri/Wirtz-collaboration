---
title: "G1-enriched vs non-enriched Senescent Cells"
author: "Francesco Neri"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      include = FALSE,
                      fig.align='center',
                      out.width="100%",
                      fig.width=7.5,
                      fig.asp=0.618)

# libraries
library(tidyverse)
library(readxl)
library(scales)
library(RColorBrewer)
library(ggplot2)
# library(multcomp) ! I think multcomp masks dplyr::fitler !
```

Data on functional comparison between G1-enriched vs non-enriched senescent endothelial cells (induction: 15 Gy IR).

The comparison entailed 1) checking survival to ABT263/Navitoclax treatment; 2) measuring IL6 protein secretion in the conditioned medium.

```{r tidy_IAoutput}

# adjust IA output excel file to have tidy format
tidy_IAoutput <- function(data,
                          Nuclear_Area_channel_number = 0,
                          DAPI_channel_number = 1) {
  
  IAoutput <- data
  
  # change Plot_Name/Name column name to Well
  IAoutput <- if ( any(colnames(IAoutput) %in% "Plot Name") ) {
    IAoutput %>% dplyr::rename(Well = "Plot Name")
  } else {
    IAoutput %>% dplyr::rename(Well = Name)
  }
  
  # remove extra columns
  
  ## the pattern looks for "Well", "Channel", or "OBJ" followed by any number
  ## the regular expression is case insensitive, indicated by (?i)
  pattern_to_keep <- "^(?i)(Well|Channel|OBJ[0-9]*)$"
  
  cols_to_keep <- grepl(pattern_to_keep, names(IAoutput))
  
  IAoutput <- IAoutput[, cols_to_keep]
  
  # pivot_longer()
  OBJ_vec <- colnames(IAoutput)[-(1:2)]
  
  tidy_data1 <-  tidyr::pivot_longer(IAoutput, dplyr::all_of(OBJ_vec),
                                     names_to = "cell_ID",
                                     values_to = "Signal_Intensity")
  
  # adjust Channel column name and values
  
  tidy_data1 <- tidy_data1 %>%
    dplyr::rename(Measured_Parameter = .data$Channel) %>%
    dplyr::mutate(Measured_Parameter = dplyr::case_when(
      Measured_Parameter == 0 ~ "Nuclear_Area",
      Measured_Parameter == 1 ~ "DAPI",
      .default = NA)
    )
  
  # adjust Well column values - extract first letter followed by 2 digits
  
  tidy_data1 <- tidy_data1 %>%
    dplyr::mutate(Well = stringr::str_extract(.data$Well, "[A-Za-z]\\d{2}")) %>%
    dplyr::select(.data$Well, .data$cell_ID, dplyr::everything()) # rearrange column order
  
  # pivot_wider()
  
  tidy_data2 <- tidy_data1 %>%
    tidyr::pivot_wider(names_from = .data$Measured_Parameter,
                       values_from = .data$Signal_Intensity) %>%
    stats::na.omit() # remove cells that had with blank/NA signal intensities in IAoutput file
  
  tidy_data2
}

```

# Load & Check Data

```{r load ABT263 data}

# Generate file paths
Paths <- tibble(
  Dataset = factor(c("FN048.01","FN048.02","FN048.03"))
) %>%
  mutate(
    Folder_Path = paste0("inst/extdata/",Dataset),
    File_Name = list(paste0("IAoutput_", c("P1-ABT263","P2-ABT263")))
  ) %>%
  unnest(File_Name) %>%
  mutate(
    Complete_Path = file.path(Folder_Path, File_Name) %>%
      paste0(., ".xlsx")
  )

# Load ABT263 data
df_ATB263 <- Paths %>%
  mutate(
    # read IAoutput
    Data = map(Complete_Path, ~ readxl::read_xlsx(path = .x, skip = 1, na = "NA") %>%
                 # tidy IAoutput
                 tidy_IAoutput(.)),
    # Load metadata
    Metadata_Path = Complete_Path %>%
      str_replace_all(.,
                      pattern = ".xlsx",
                      replacement = "_metadata.csv"),
    Metadata = map(Metadata_Path,
                   ~ plater::read_plate(file = .x,
                                        well_ids_column = "Well")
                   ),
    # Remove Variable3 empty col
    Metadata = map(Metadata,
                   ~ select(.x, -Variable3)),
    # Add metadata to data
    Data = pmap(
      list(Data,
           Metadata),
      ~ left_join(.x,.y)
    )
    ) %>%
  # Combine P1 and P2 data
  group_by(Dataset) %>%
  summarise(
    Data_ABT263 = list(bind_rows(Data)),
    .groups = "drop"
  )

df_ATB263
df_ATB263$Data_ABT263

```

```{r  load IL6 data}

# Load IL6 data
Paths <- Paths %>%
  # Dataset and Folder Path
  group_by(Dataset,Folder_Path) %>%
  nest() %>%
  ungroup() %>%
  select(-data) %>%
  # Add File Name
  left_join(
    .,
    expand(.,
       Dataset,
       File_Name = c("IAoutput_P3-IL6.xlsx", "IAoutput_P3-IL6_metadata.csv", "IL6-ELISA.csv"))
  ) %>%
  mutate(
    Complete_Path = file.path(Folder_Path,File_Name)
  )

df_IL6 <- Paths %>%
  # TEMPORARY: Filter for FN48.1
  filter(Dataset == "FN048.01") %>%
  mutate(
    Data = map(
      Complete_Path,
      ~ if (str_ends(.x, pattern = ".xlsx")) {
        # Read IAoutput files (cell count data)
        readxl::read_xlsx(.x, skip = 1, na = "NA") %>%
          # tidy IAoutput
          tidy_IAoutput(.)
      } else {
        plater::read_plate(.x, well_ids_column = "Well")
      }
    )
  ) %>%
  # remove paths to simplify tibble
  select(Dataset, File_Name, Data)

```

```{r merge IL6 IAoutput w metadata}

df_cell_counts <- df_IL6 %>%
  # keep only IAoutput and metadata files
  filter(File_Name != "IL6-ELISA.csv") %>%
  pivot_wider(names_from = File_Name,
              values_from = Data) %>%
  # add metadata to data
  mutate(
    Cell_Count_Data = pmap(
      list(`IAoutput_P3-IL6.xlsx`, `IAoutput_P3-IL6_metadata.csv`),
      left_join
    )
  ) %>%
  # keep only full data
  select(Dataset, Cell_Count_Data)

```


```{r plot IL6 cell counts per well}

df_cell_counts %>%
  # calculate cell counts by well
  mutate(
    Cell_Count_Data = map(
      Cell_Count_Data,
    ~ .x %>%
        group_by(Condition,Well) %>%
        summarise(Cell_Count = n()) %>%
        ungroup()
    )
  ) %>%
  # plot
  pmap(
    .,
    function(Cell_Count_Data, Dataset) {
      ggplot(Cell_Count_Data) +
             geom_point(aes(x = Condition,
                            y = Cell_Count,
                            fill = Condition),
                        shape = 21,
                        color = "black") +
        labs(title = Dataset)
    }
  )

```

```{r Data_IL6}

df_ELISA <- df_IL6 %>%
    # keep only IL6-ELISA data
    filter(File_Name == "IL6-ELISA.csv") %>%
    # calculate mean luminescence from ELISA
    mutate(
      ELISA_Data = map(
        Data,
        ~ .x %>%
          group_by(Condition, Sample) %>%
          summarise(Luminescence = mean(Luminescence),
                    # Carry over the Concentration col as well
                    Concentration = mean(Concentration)
                    ) %>%
          ungroup()
      )
    ) %>%
  # remove unnecessary cols
  select(-c(Data,File_Name))

Data_IL6 <- df_cell_counts %>%
  # Calculate cell counts for each Sample in all Conditions
  mutate(
    Cell_Count_Data = map(
      Cell_Count_Data,
      ~ .x %>%
        group_by(Condition, Sample) %>%
        summarise(Cell_Count = n()) %>%
        ungroup()
        )
    ) %>%
  # Add cell counts to ELISA data
  left_join(
    df_ELISA,
    .
  ) %>%
  mutate(
    Data = pmap(
      list(ELISA_Data, Cell_Count_Data),
      left_join
    )
  ) %>%
  # simplify df
  select(Dataset, Data)

```

# IL6 expression

Regress IL6 concentration
- subtract blank
- calculate linear model
- regress out IL6 concentrations
- normalize to cell counts

## plot

# ABT263 susceptibility

## plot


```{r load IAoutput files and metadata, include=FALSE}
  
  # load metadata files
  # unite IAoutput with metadata
  # merge P1 and P2
  
  c(
  P1 = "inst/extdata/FN048.01/IAoutput_P1.xlsx",
  P2 = "inst/extdata/FN048.01/IAoutput_P2.xlsx",
  P3_IL6 = "inst/extdata/FN048.01/IAoutput_P3-IL6.xlsx"
  ) %>%
  tibble(plate = c("P1","P2","P3_IL6"),
         paths = .) %>%
  # read excel files
  mutate(
    data = map(.$paths,
               readxl::read_xlsx,
               skip=1, na="NA"
               )
  )

df

# read xlsx files
IAoutput_dfs <- map(
  
)


IAoutput_dfs <- vector(mode = "list", length = length(IAoutput_datapaths))

for (i in seq_along(IAoutput_dfs)) {
  IAoutput_dfs[[i]] <- readxl::read_xlsx(IAoutput_datapaths[i], skip = 1, na = "NA")
}

# metadata files
metadata_datapaths <- IAoutput_datapaths %>%
  gsub(pattern = ".xlsx", replacement = "_metadata.csv")

metadata_dfs <- vector(mode = "list", length = length(metadata_datapaths))

for (i in seq_along(metadata_dfs)) {
  metadata_dfs[[i]] <- plater::read_plate(file = metadata_datapaths[i],
                                                           well_ids_column = "Well",    # name to give column of Well IDs
                                                           sep = ",") %>%               # separator used in the csv file
          dplyr::select(dplyr::where(~ !all(is.na(.x)))) # remove columns whose values are all NA
  
  # convert variables to factors
  cols_to_factor <- setdiff(names(metadata_dfs[[i]]), "Well") # Identify all columns except 'Well'
  metadata_dfs[[i]][cols_to_factor] <- lapply(metadata_dfs[[i]][cols_to_factor], as.factor)

}

# input files
Input_files <- tibble::tibble(
  IAoutput_dfs = IAoutput_dfs,
  metadata_dfs = metadata_dfs,
  plate_names = plate_names
)

```

```{r tidy and merge metadata, include=FALSE}

Input_files$tidy_df <- vector(mode = "list", length = nrow(Input_files)) # create emtpy list-column to store tidy data
      
for (i in seq_len(nrow(Input_files))) {
  
  # tidy IAoutput
  tidied_IAoutput <- tidy_IAoutput(Input_files$IAoutput_dfs[[i]])
  
  # add metadata to tidied_IAoutput
  df <- dplyr::left_join(tidied_IAoutput, Input_files$metadata_dfs[[i]])
  
  # add plate identifier (i.e. file name) and rearrange column names
  variable_names <- names(Input_files$metadata_dfs[[i]])[-(names(Input_files$metadata_dfs[[i]]) == "Well")]
  
  df <- df %>%
    dplyr::mutate(plate = Input_files$plate_names[i]) %>% # add plate name
    dplyr::select(.data$plate, .data$Well, .data$cell_ID, dplyr::all_of(variable_names), dplyr::everything()) # rearrange
  
  # return df
  Input_files$tidy_df[[i]] <- df
}

```

## ABT263 treatment

```{r df_ABT263, include=FALSE}

df_ABT263 <- dplyr::bind_rows(Input_files$tidy_df[[1]], Input_files$tidy_df[[2]])

```

```{r ggplot settings, include=FALSE}

# ggplot theme
theme_set(theme_bw())

theme(
  legend.title = element_text(size = 16),
  legend.text = element_text(size = 14),
  axis.title = element_text(size = 16),
  axis.text = element_text(size = 14),
  strip.text = element_text(size = 16) # facets
  )

# palette
palette <- "Accent"

scale_color_brewer_conditions <- ggplot2::scale_color_brewer(palette = palette,
                                                             limits = unique(df_ABT263$Condition),
                                                             direction = 1)

scale_fill_brewer_conditions <- ggplot2::scale_fill_brewer(palette = palette,
                                                             limits = unique(df_ABT263$Condition),
                                                             direction = 1)



```


### DNA content 

```{r DNA content histogram}

# dead-cells threshold
dead_cells_threshold <- 3800000

# G1-G2 threshold
G1_G2_threshold <- 10500000

# generate histogram
ggplot(data = df_ABT263) +
  geom_histogram(
    aes(x = DAPI,
        fill = Condition),
    binwidth = quantile(df_ABT263$DAPI, 0.99)/100) +
  facet_grid(rows = vars(Condition),
             cols = vars(ABT263)) +
  geom_vline(xintercept = dead_cells_threshold,
             color = "red") +
  geom_vline(xintercept = G1_G2_threshold) +
  labs(y = "Counts",
       x = "DNA Content (DAPI staining, A.U.)",
       fill = "Condition") +
  scale_x_continuous(limits = c(0,quantile(df_ABT263$DAPI, 0.99))) +
  scale_fill_brewer_conditions +
  theme(axis.text = element_text(size = 6))

```

## Percentages

```{r Percentages, include=FALSE}

df_ABT263 <- df_ABT263 %>%
  mutate(DNA_content = case_when(
    DAPI <= dead_cells_threshold ~ "dead",
    DAPI > dead_cells_threshold & DAPI <= G1_G2_threshold ~ "G1",
    DAPI > G1_G2_threshold ~ "G2"
  ))

df_ABT263_no_dead <- df_ABT263 %>%
  filter(DNA_content != "dead")

calculate_percentage <- function(data) {
  data %>%
  group_by(plate, Condition, ABT263, Well, DNA_content) %>%
  summarise(
    cell_count = n()
  ) %>%
  group_by(plate, Well) %>%
  mutate(tot_cell_count = sum(cell_count),
         percentage = cell_count / tot_cell_count) %>%
  ungroup()
}

df_percentage <- calculate_percentage(df_ABT263)

df_percentage_no_dead <- calculate_percentage(df_ABT263_no_dead)

```

```{r plot_DNA_content_percentages, include=FALSE}

plot_DNA_content_percentages <- function(data) {
  
  ggplot(data,
       aes(x = Condition,
           y = percentage,
           color = Condition)
       ) +
  geom_boxplot() +
  geom_point(
    shape = 21,
    color = "black",
    aes(fill = Condition)
  ) +
  facet_grid(
    rows = vars(DNA_content),
    cols = vars(ABT263)
  ) +
  scale_y_continuous(limits = c(0,1),
                     breaks = seq(from = 0, to = 1, by = 0.2),
                     labels = scales::percent) +
  scale_color_brewer_conditions +
  scale_fill_brewer_conditions
  
}

```

### **including** dead cells

```{r plot perentages}

plot_DNA_content_percentages(df_percentage)

```

### **excluding** dead cells

```{r plot perentages no dead}

plot_DNA_content_percentages(df_percentage_no_dead)

```

```{r df_viability}

# overall viability
# Step 1: Filter for ABT263 == "0 µM ABT263"
filtered_data <- df_percentage_no_dead %>% filter(ABT263 == "0.00 µM ABT263")

# Step 2 and 3: Group by Condition and DNA_content, then calculate mean
mean_counts <- filtered_data %>% 
  group_by(Condition) %>% 
  summarize(reference_count = mean(tot_cell_count, na.rm = TRUE))

# Step 4: Merge with original data
df_viability <- df_percentage_no_dead %>% 
  left_join(mean_counts, by = c("Condition")) %>%
  filter(DNA_content == "G1") %>%
  mutate(viability = tot_cell_count/reference_count)

# DNA_content specific viability
# Step 2 and 3: Group by Condition and DNA_content, then calculate mean
mean_counts <- filtered_data %>% 
  group_by(Condition, DNA_content) %>% 
  summarize(reference_count = mean(cell_count, na.rm = TRUE))

# Step 4: Merge with original data
df_viability_DNA_content <- df_percentage_no_dead %>% 
  left_join(mean_counts, by = c("Condition", "DNA_content")) %>%
  mutate(viability = cell_count/reference_count)

```


```{r function plot viability}

plot_viability <- function(data) {
  
  data$ABT263 <- data$ABT263 %>%
    str_remove_all(" µM ABT263")
  
  ggplot(data,
       aes(x = ABT263,
           y = viability,
           color = Condition)
       ) +
    geom_hline(yintercept = 1.0,
               color = "grey") +
  geom_boxplot() +
  geom_point(
    shape = 21,
    color = "black",
    aes(fill = Condition)
  ) +
  facet_grid(
    rows = vars(DNA_content),
    cols = vars(Condition)
  ) +
  scale_y_continuous(limits = c(0,1.7),
                     breaks = seq(from = 0, to = 2, by = 0.2),
                     labels = scales::percent) +
  scale_color_brewer_conditions +
  scale_fill_brewer_conditions
  
}

```

```{r plot viability, fig.asp=0.4}

plot_viability(df_viability)

```

```{r plot viability DNA_content}

plot_viability(df_viability_DNA_content)

```

```{r function viability DNA content grouped plot}

plot_viability_grouped <- function(data) {
  
  data$ABT263 <- data$ABT263 %>%
    str_remove_all(" µM ABT263")
  
  ggplot(data, aes(x = ABT263, y = viability)) +
    geom_hline(yintercept = 1.00,
               color = "grey") +
    geom_boxplot(aes(color = DNA_content),
                 position = position_dodge(width = 0.85)) + # Dodge to avoid overlap
    geom_point(color = "black",
               aes(fill = Condition,
                   shape = DNA_content),
               position = position_dodge(width = 0.85)) +  # Dodge to avoid overlap
    labs(x = "ABT263", y = "Viability") +
    facet_grid(
      cols = vars(Condition)
    ) +
    scale_y_continuous(limits = c(0,1.7),
                       breaks = seq(from = 0, to = 2, by = 0.2),
                       labels = scales::percent) +
    scale_shape_manual(values = c(21,22)) +
    scale_color_manual(values = c("G1" = "darkgrey", "G2" = "black")) +
    scale_fill_brewer_conditions
}

```

```{r function viability DNA content grouped, fig.asp=0.4}

plot_viability_grouped(df_viability_DNA_content)

```


## IL6 expression

```{r df_IL6}

df_IL6 <- Input_files$tidy_df[[3]]

# store old col names
old_colnames <- df_IL6 %>% names()

# adapt col names
names(df_IL6) <- names(df_IL6) %>% make.names()

# convert factor back to numeric
df_IL6$IL6_pg.mL <- df_IL6$IL6_pg.mL %>% as.character() %>% as.numeric()

# nomralize IL6 expression to cell count
df_IL6 <- df_IL6 %>%
  group_by(Condition, IL6_pg.mL) %>%
  summarise(
    cell_counts = n()
  ) %>%
  ungroup() %>%
  mutate(
    IL6_pg.mL_per_cell = IL6_pg.mL / cell_counts
  )

```

```{r function IL6 plot}

plot_IL6 <- function(data) {
  
  ggplot(data,
         aes(x = Condition,
             y = IL6_pg.mL_per_cell,
             color = Condition)
         ) +
    geom_boxplot() +
    geom_point(
      shape = 21,
      color = "black",
      aes(fill = Condition)
    ) +
    scale_y_continuous(name = "IL6 (pg/mL per cell)",
                       limits = c(NA, 0.35)) +
    scale_color_brewer_conditions +
    scale_fill_brewer_conditions
  
}

```

```{r IL6 stats}

# ANOVA
anova_result <- aov(IL6_pg.mL_per_cell ~ Condition, data = df_IL6)
summary(anova_result)

# If ANOVA is significant, proceed with post-hoc test
if(summary(anova_result)[[1]]$'Pr(>F)'[1] < 0.05) {
  # Tukey's HSD Test
  post_hoc_result <- TukeyHSD(anova_result)
  print(post_hoc_result)
  
  # Optional: Plotting the results
  plot(post_hoc_result)
}

```


```{r plot IL6, fig.width=4, out.width="50%"}



```

```{r Notes}



```

